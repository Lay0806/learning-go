package main

import (
	"fmt"
	"unsafe"
)

func main() {
	a := f()
	b := f2()
	fmt.Println(a)
	fmt.Println(b)
}

//go:noinline
func f() unsafe.Pointer {
	d := 1
	p := unsafe.Pointer(&d)
	return p
}

//go:noinline
func f2() uintptr {
	d := 1
	p := uintptr(unsafe.Pointer(&d)) // 返回的是uint整数
	return p
}

/*
go build -gcflags '-m -m' unsafe.go  编译参数方法执行
# command-line-arguments
./unsafe.go:16:6: cannot inline f: marked go:noinline
./unsafe.go:23:6: cannot inline f2: marked go:noinline
./unsafe.go:8:6: cannot inline main: function too complex: cost 278 exceeds budget 80
./unsafe.go:11:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = <N>; var fmt..autotmp_4 error; fmt..autotmp_4 = <N>; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 }
./unsafe.go:12:13: inlining call to fmt.Println func(...interface {}) (int, error) { var fmt..autotmp_3 int; fmt..autotmp_3 = <N>; var fmt..autotmp_4 error; fmt..autotmp_4 = <N>; fmt..autotmp_3, fmt..autotmp_4 = fmt.Fprintln(io.Writer(os.Stdout), fmt.a...); return fmt..autotmp_3, fmt..autotmp_4 }
./unsafe.go:17:2: d escapes to heap:
./unsafe.go:17:2:   flow: p = &d:
./unsafe.go:17:2:     from &d (address-of) at ./unsafe.go:18:22
./unsafe.go:17:2:     from p := unsafe.Pointer(&d) (assign) at ./unsafe.go:18:4
./unsafe.go:17:2:   flow: ~r0 = p:
./unsafe.go:17:2:     from return p (return) at ./unsafe.go:19:2
./unsafe.go:17:2: moved to heap: d
./unsafe.go:12:13: b escapes to heap:
./unsafe.go:12:13:   flow: ~arg0 = &{storage for b}:
./unsafe.go:12:13:     from b (spill) at ./unsafe.go:12:13
./unsafe.go:12:13:     from ~arg0 = <N> (assign-pair) at ./unsafe.go:12:13
./unsafe.go:12:13:   flow: {storage for []interface {} literal} = ~arg0:
./unsafe.go:12:13:     from []interface {} literal (slice-literal-element) at ./unsafe.go:12:13
./unsafe.go:12:13:   flow: fmt.a = &{storage for []interface {} literal}:
./unsafe.go:12:13:     from []interface {} literal (spill) at ./unsafe.go:12:13
./unsafe.go:12:13:     from fmt.a = []interface {} literal (assign) at ./unsafe.go:12:13
./unsafe.go:12:13:   flow: {heap} = *fmt.a:
./unsafe.go:12:13:     from fmt.Fprintln(io.Writer(os.Stdout), fmt.a...) (call parameter) at ./unsafe.go:12:13
./unsafe.go:11:13: []interface {} literal does not escape
./unsafe.go:12:13: b escapes to heap
./unsafe.go:12:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape

汇编输出:
				go tool compile -S unsafe.go| grep unsafe.go:24
        0x000e 00014 (unsafe.go:24)     PCDATA  $0, $0
        0x000e 00014 (unsafe.go:24)     PCDATA  $1, $0
				0x000e 00014 (unsafe.go:24)     MOVQ    $1, "".d(SP)

				go tool compile -S unsafe.go| grep unsafe.go:17
        0x001d 00029 (unsafe.go:17)     PCDATA  $0, $1
        0x001d 00029 (unsafe.go:17)     PCDATA  $1, $0
        0x001d 00029 (unsafe.go:17)     LEAQ    type.int(SB), AX
        0x0024 00036 (unsafe.go:17)     PCDATA  $0, $0
        0x0024 00036 (unsafe.go:17)     MOVQ    AX, (SP)
        0x0028 00040 (unsafe.go:17)     CALL    runtime.newobject(SB)
        0x002d 00045 (unsafe.go:17)     PCDATA  $0, $1
        0x002d 00045 (unsafe.go:17)     MOVQ    8(SP), AX
				0x0032 00050 (unsafe.go:17)     MOVQ    $1, (AX)

				f 中的 d 调用了 newobject，但是 f2 中没有
				unsafe 包不安全呢，原因之一就是因为 go 不保证地址一定是有效的
*/
